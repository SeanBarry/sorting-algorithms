{"version":3,"sources":["types.ts","App.styles.ts","constants.ts","utils.ts","algorithms/bubbleSort.tsx","algorithms/insertionSort.tsx","algorithms/quickSort.tsx","algorithms/selectionSort.tsx","algorithms/radixSort.tsx","App.tsx","reportWebVitals.js","index.js"],"names":["SortingAlgorithm","BACKGROUND","PRIMARY","SECONDARY","Div","styled","div","Wrapper","ToolBar","element","value","colour","ArrayWrapper","Credits","p","Link","a","Button","button","primary","Select","select","SliderWrapper","SliderDescription","Slider","input","Rows","Description","P","small","Highlight","span","MAX_SPEED","shuffle","array","tempValue","randomIdx","currentIndex","length","Math","floor","random","swap","i","j","temp","ELEMENT_COLOURS","sleep","duration","Promise","resolve","setTimeout","setColour","index","bubbleSort","setArray","speed","isSorted","counter","next","current","map","w","bubbleSortDescription","insertionSort","insertionSortDescription","quickSort","quickSortHelper","startIdx","endIdx","timeToWait","leftIdx","rightIdx","pivotIdx","quickSortDescription","selectionSort","currentIdx","smallestIdx","selectionSortDescription","countingSort","digit","isLastPass","sortedArray","Array","fill","countArray","digitColumn","countIndex","idx","sortedIndex","radixSort","maxNumber","max","maxNumberLength","toString","radixSortDescription","href","target","rel","App","useState","inProgress","setInProgress","arraySize","setArraySize","maxArraySize","setMaxArraySize","sortSpeed","setSortSpeed","BubbleSort","sortingAlgorithm","setSortingAlgorithm","mainContentWidth","useRef","useEffect","offsetWidth","number","shuffleArray","sortArray","SelectionSort","InsertionSort","QuickSort","RadixSort","from","_","shuffled","isAlgoDisabled","key","MergeSort","HeapSort","BogoSort","ref","style","width","marginLeft","color","display","height","backgroundColor","getAlgorithmDescription","onChange","event","typedValue","disabled","Object","values","val","Number","type","min","onClick","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f5a16ee5.chunk.js","sourcesContent":["export enum SortingAlgorithm {\n  BubbleSort = \"Bubble Sort\",\n  InsertionSort = \"Insertion Sort\",\n  SelectionSort = \"Selection Sort\",\n  QuickSort = \"Quick Sort\",\n  RadixSort = \"Radix Sort\",\n  MergeSort = \"Merge Sort (Coming soon)\",\n  HeapSort = \"Heap Sort (Coming soon)\",\n  BogoSort = \"Bogo Sort (Coming soon)\",\n}\n\nexport type ArrayItem = {\n  value: number;\n  colour: string;\n};\n","import { ArrayItem } from \"./types\";\nimport styled from \"styled-components\";\n\nexport const BACKGROUND = \"#fffffe\";\nexport const BACKGROUND_SECONDARY = \"#232946\";\nexport const PRIMARY = \"#3da9fc\";\nexport const SECONDARY = \"#ef4565\";\nexport const TERTIARY = \"#ffc107\";\n\nexport const BAR_WIDTH = 4;\nexport const BAR_SPACE = 4;\n\nconst Div = styled.div`\n  box-sizing: border-box;\n`;\n\nexport const Wrapper = styled(Div)`\n  width: 100%;\n  height: 100%;\n  background-color: ${BACKGROUND};\n  display: flex;\n\n  @media (min-width: 768px) {\n    flex-direction: row-reverse;\n  }\n\n  @media (max-width: 768px) {\n    flex-direction: column;\n  }\n`;\n\ntype ArrayItemProps = {\n  key: number;\n  element: ArrayItem;\n};\n\nexport const ArrayElement = styled.div<ArrayItemProps>`\n  width: ${BAR_WIDTH}px;\n  margin-left: ${BAR_SPACE}px;\n  color: transparent;\n  display: inline-block;\n  height: ${({ element }) => element.value * 3}px;\n  background-color: ${({ element }) => element.colour};\n`;\n\nexport const ToolBar = styled(Div)`\n  background: ${BACKGROUND_SECONDARY};\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 30px;\n  height: 100%;\n  width: 250px;\n  border-right: 3px solid rgb(9 64 103);\n  flex-direction: column;\n\n  @media (max-width: 768px) {\n    border-right: none;\n    width: 100%;\n  }\n`;\n\nexport const ArrayWrapper = styled(Div)`\n  padding: 30px;\n  width: 100%;\n  height: 100%;\n  background-color: ${BACKGROUND};\n  display: flex;\n  align-items: center;\n  justify-content: center;\n`;\n\nexport const Credits = styled.p`\n  font-family: sans-serif;\n  font-size: 12px;\n  color: #fff;\n`;\n\nexport const Link = styled.a`\n  color: ${SECONDARY};\n  font-weight: bold;\n  text-decoration: none;\n\n  &:hover,\n  &:focus,\n  &:active {\n    color: #bc2944;\n  }\n`;\n\nexport const Button = styled.button<{ primary?: boolean }>`\n  background: ${({ primary }) => (primary ? SECONDARY : BACKGROUND)};\n  width: 100%;\n  border: none;\n  padding: 1rem 2rem;\n  margin: 10px 0;\n  text-decoration: none;\n  color: ${({ primary }) => (primary ? \"#fff\" : \"#2b2c34\")};\n  font-family: sans-serif;\n  font-size: 1rem;\n  font-weight: bold;\n  line-height: 1;\n\n  cursor: pointer;\n  text-align: center;\n  transition: background 250ms ease-in-out, transform 150ms ease;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n\n  &:disabled {\n    cursor: not-allowed;\n    opacity: 0.7;\n  }\n\n  &:hover {\n    background: ${({ primary }) => (primary ? \"#bc2944\" : \"#cfcfcf\")};\n  }\n`;\n\nexport const Select = styled.select`\n  width: 100%;\n  font-family: sans-serif;\n  font-size: 1rem;\n  font-weight: bold;\n  line-height: 1;\n  padding: 15px 0px;\n  margin: 10px 0px;\n  text-align: center;\n\n  &:disabled {\n    cursor: not-allowed;\n  }\n\n  &:focus {\n    outline: none;\n  }\n`;\n\nexport const SliderWrapper = styled(Div)`\n  padding: 10px 0px;\n  width: 100%;\n`;\n\nexport const SliderDescription = styled.p`\n  font-family: sans-serif;\n  color: #fffffe;\n  font-size: 1rem;\n  font-weight: bold;\n  line-height: 1;\n  margin: 0px;\n`;\n\nexport const Slider = styled.input`\n  margin: 10px 0;\n  height: 25px;\n  -webkit-transition: 0.2s;\n  transition: opacity 0.2s;\n  -webkit-appearance: none;\n  width: 100%;\n\n  &::-webkit-slider-thumb {\n    -webkit-appearance: none;\n    appearance: none;\n    width: 25px;\n    height: 25px;\n    background: ${SECONDARY};\n    cursor: pointer;\n\n    &:disabled {\n      opacity: 0.7;\n      cursor: not-allowed;\n    }\n  }\n\n  &:focus {\n    outline: none;\n  }\n\n  &:disabled {\n    opacity: 0.7;\n    background: white;\n    cursor: not-allowed;\n  }\n`;\n\nexport const Rows = styled.div`\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n`;\n\nexport const Description = styled.div`\n  padding: 30px 30px 10px 30px;\n  align-self: flex-start;\n  justify-content: center;\n  margin: 0px;\n`;\n\ntype PProps = {\n  small?: boolean;\n};\n\nexport const P = styled.p<PProps>`\n  font-size: ${({ small }) => (small ? \"12px\" : \"16px\")};\n  font-family: sans-serif;\n  line-height: 1.8;\n`;\n\nexport const Highlight = styled.span`\n  color: ${SECONDARY};\n`;\n","export const MAX_SPEED = 400;\nexport const MAX_ARRAY_SIZE = 100;\n","import { PRIMARY, SECONDARY, TERTIARY } from \"./App.styles\";\n\nimport { ArrayItem } from \"./types\";\n\nexport const shuffle = (array: Array<any>) => {\n  let currentIndex = array.length;\n  let tempValue;\n  let randomIdx;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n    // Pick a remaining element...\n    randomIdx = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    tempValue = array[currentIndex];\n    array[currentIndex] = array[randomIdx];\n    array[randomIdx] = tempValue;\n  }\n\n  return array;\n};\n\nexport const swap = (i: number, j: number, array: Array<ArrayItem>) => {\n  const temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n};\n\nexport const ELEMENT_COLOURS = {\n  DEFAULT: PRIMARY,\n  SORTED: SECONDARY,\n  FOCUSED: TERTIARY,\n};\n\nexport const createArrayItem = (value: number): ArrayItem => ({\n  value,\n  colour: PRIMARY,\n});\n\nexport const sleep = (duration: number): Promise<void> =>\n  new Promise((resolve) => setTimeout(() => resolve(), duration));\n\nexport const setColour = (\n  index: number,\n  colour: string,\n  array: Array<ArrayItem>\n) => {\n  const element = array[index];\n\n  if (element) {\n    element.colour = colour;\n  }\n};\n","import { ELEMENT_COLOURS, setColour, sleep, swap } from \"../utils\";\n\nimport { ArrayItem } from \"../types\";\nimport { MAX_SPEED } from \"../constants\";\nimport { P } from \"../App.styles\";\n\nexport const bubbleSort = async (\n  array: Array<ArrayItem>,\n  setArray: (array: Array<ArrayItem>) => void,\n  speed: number\n) => {\n  let isSorted = false;\n  let counter = 0;\n\n  while (!isSorted) {\n    isSorted = true;\n\n    for (let i = 0; i < array.length - 1 - counter; i++) {\n      let next = array[i + 1];\n      let current = array[i];\n      setColour(i, ELEMENT_COLOURS.FOCUSED, array);\n      setArray([...array]);\n\n      await sleep(MAX_SPEED - speed);\n\n      if (current.value > next.value) {\n        swap(i, i + 1, array);\n        setArray([...array]);\n\n        isSorted = false;\n      }\n\n      setColour(i, ELEMENT_COLOURS.DEFAULT, array);\n    }\n\n    counter++;\n    setColour(array.length - counter, ELEMENT_COLOURS.SORTED, array);\n    setArray([...array]);\n  }\n\n  setArray(array.map((w) => ({ ...w, colour: ELEMENT_COLOURS.SORTED })));\n};\n\nexport const bubbleSortDescription = (\n  <>\n    <P>\n      <strong>Bubble Sort - O(N^2) average time complexity.</strong>\n    </P>\n    <P>\n      Bubble sort repeatedly iterates over a list from left to right. At each\n      value a comparison is made - if the current value is greater than the next\n      value, their positions are swapped. This results in the largest value\n      moving to the end of the unsorted list in each iteration.\n    </P>\n  </>\n);\n","import { ELEMENT_COLOURS, setColour, sleep, swap } from \"../utils\";\n\nimport { ArrayItem } from \"../types\";\nimport { MAX_SPEED } from \"../constants\";\nimport { P } from \"../App.styles\";\n\nexport const insertionSort = async (\n  array: Array<ArrayItem>,\n  setArray: (array: Array<ArrayItem>) => void,\n  speed: number\n) => {\n  setColour(0, ELEMENT_COLOURS.SORTED, array);\n  setArray([...array]);\n\n  for (let i = 1; i < array.length; i++) {\n    let j = i;\n\n    setColour(j, ELEMENT_COLOURS.FOCUSED, array);\n    setArray([...array]);\n\n    while (j > 0 && array[j].value < array[j - 1].value) {\n      setColour(j, ELEMENT_COLOURS.FOCUSED, array);\n      setArray([...array]);\n      await sleep(MAX_SPEED - speed);\n      swap(j, j - 1, array);\n      setColour(j - 1, ELEMENT_COLOURS.SORTED, array);\n      setColour(j, ELEMENT_COLOURS.SORTED, array);\n      setArray([...array]);\n      j--;\n    }\n    setColour(i, ELEMENT_COLOURS.SORTED, array);\n    setArray([...array]);\n  }\n\n  setArray(array.map((w) => ({ ...w, colour: ELEMENT_COLOURS.SORTED })));\n};\n\nexport const insertionSortDescription = (\n  <>\n    <P>\n      <strong>Insertion Sort - O(N^2) average time complexity.</strong>\n    </P>\n    <P>\n      Insertion sort designates a sorted output list at the start of the list.\n      To begin with this is just the first value in the unsorted list. The\n      algorithm then iterates over the unsorted list. At each iteration, it\n      removes one element from the list, and traverses down the sorted list to\n      find a location for the item. It repeats, building up a sorted list of\n      values on the left hand side, until no unsorted elements remain.\n    </P>\n  </>\n);\n","import { ELEMENT_COLOURS, setColour, sleep, swap } from \"../utils\";\n\nimport { ArrayItem } from \"../types\";\nimport { MAX_SPEED } from \"../constants\";\nimport { P } from \"../App.styles\";\n\nexport const quickSort = async (\n  array: Array<ArrayItem>,\n  setArray: (array: Array<ArrayItem>) => void,\n  speed: number\n) => {\n  await quickSortHelper(array, 0, array.length - 1, setArray, speed);\n\n  setArray(array.map((w) => ({ ...w, colour: ELEMENT_COLOURS.SORTED })));\n};\n\nconst quickSortHelper = async (\n  array: Array<ArrayItem>,\n  startIdx: number,\n  endIdx: number,\n  setArray: (array: Array<ArrayItem>) => void,\n  speed: number\n) => {\n  if (startIdx >= endIdx) {\n    return;\n  }\n\n  const timeToWait = Math.floor((MAX_SPEED - speed) / 4);\n\n  let pivotIdx = startIdx;\n  let leftIdx = startIdx + 1;\n  let rightIdx = endIdx;\n\n  setColour(pivotIdx, ELEMENT_COLOURS.FOCUSED, array);\n  setColour(leftIdx, ELEMENT_COLOURS.FOCUSED, array);\n  setColour(rightIdx, ELEMENT_COLOURS.FOCUSED, array);\n  setArray([...array]);\n\n  await sleep(timeToWait);\n\n  while (rightIdx >= leftIdx) {\n    if (\n      array[leftIdx].value > array[pivotIdx].value &&\n      array[rightIdx].value < array[pivotIdx].value\n    ) {\n      swap(leftIdx, rightIdx, array);\n      setArray([...array]);\n      await sleep(timeToWait);\n    }\n\n    if (array[leftIdx].value <= array[pivotIdx].value) {\n      setColour(leftIdx, ELEMENT_COLOURS.DEFAULT, array);\n      setColour(leftIdx + 1, ELEMENT_COLOURS.FOCUSED, array);\n      setArray([...array]);\n      await sleep(timeToWait);\n      leftIdx += 1;\n    }\n\n    if (array[rightIdx].value >= array[pivotIdx].value) {\n      setColour(rightIdx, ELEMENT_COLOURS.DEFAULT, array);\n      setColour(rightIdx - 1, ELEMENT_COLOURS.FOCUSED, array);\n      setArray([...array]);\n      await sleep(timeToWait);\n      rightIdx -= 1;\n    }\n  }\n\n  swap(pivotIdx, rightIdx, array);\n  setColour(rightIdx, ELEMENT_COLOURS.SORTED, array);\n  setColour(pivotIdx, ELEMENT_COLOURS.SORTED, array);\n  setColour(leftIdx, ELEMENT_COLOURS.SORTED, array);\n  setArray([...array]);\n  await sleep(timeToWait);\n\n  let leftSubArrayIsSmaller = rightIdx - 1 - startIdx < endIdx - (rightIdx + 1);\n\n  if (leftSubArrayIsSmaller) {\n    await quickSortHelper(array, startIdx, rightIdx - 1, setArray, speed);\n    await quickSortHelper(array, rightIdx + 1, endIdx, setArray, speed);\n  } else {\n    await quickSortHelper(array, rightIdx + 1, endIdx, setArray, speed);\n    await quickSortHelper(array, startIdx, rightIdx - 1, setArray, speed);\n  }\n};\n\nexport const quickSortDescription = (\n  <>\n    <P>\n      <strong>Quick Sort - O(N(log(N))) average time complexity.</strong>\n    </P>\n    <P>\n      Quick sort creates a pivot index in the list. In this example, the pivot\n      is always the first element. It then iterates over the list, reodering\n      elements by swapping the positions of elements that have a lower value\n      than the pivot with values that are greater than the pivot's value.\n      Eventually a point is reached where all values before are less than the\n      pivot, and all values after are greater than the pivot. The pivot then\n      swaps positions to this point, and it is in its final sorted position. The\n      algorithm is then recursively applied to both remaining lists on each side\n      of the pivot, beginning with whichever is the smallest.\n    </P>\n  </>\n);\n","import { ELEMENT_COLOURS, setColour, sleep, swap } from \"../utils\";\n\nimport { ArrayItem } from \"../types\";\nimport { MAX_SPEED } from \"../constants\";\nimport { P } from \"../App.styles\";\n\nexport const selectionSort = async (\n  array: Array<ArrayItem>,\n  setArray: (array: Array<ArrayItem>) => void,\n  speed: number\n) => {\n  let currentIdx = 0;\n\n  while (currentIdx < array.length - 1) {\n    let smallestIdx = currentIdx;\n    setColour(smallestIdx, ELEMENT_COLOURS.FOCUSED, array);\n    setArray([...array]);\n\n    for (let i = currentIdx + 1; i < array.length; i++) {\n      if (array[i].value < array[smallestIdx].value) {\n        setColour(smallestIdx, ELEMENT_COLOURS.DEFAULT, array);\n        setColour(i, ELEMENT_COLOURS.FOCUSED, array);\n        smallestIdx = i;\n        await sleep(MAX_SPEED - speed);\n        setArray([...array]);\n      }\n    }\n    swap(currentIdx, smallestIdx, array);\n    setColour(currentIdx, ELEMENT_COLOURS.SORTED, array);\n    setArray([...array]);\n    currentIdx++;\n  }\n\n  setArray(array.map((w) => ({ ...w, colour: ELEMENT_COLOURS.SORTED })));\n};\n\nexport const selectionSortDescription = (\n  <>\n    <P>\n      <strong>Selection Sort - O(N^2) average time complexity.</strong>\n    </P>\n    <P>\n      Selection sort splits the list in to a sorted list and an unsorted list.\n      Initially, the sorted list is empty. The algorithm repeatedly iterates\n      over the unsorted list, in each iteration storing the index of the\n      smallest value. At the end of the iteration, the smallest value will be\n      swapped with the first item in the unsorted list. This builds up a sorted\n      list of ascending value on the left hand side.\n    </P>\n  </>\n);\n","import { ELEMENT_COLOURS, setColour, sleep } from \"../utils\";\nimport { Highlight, Link, P } from \"../App.styles\";\n\nimport { ArrayItem } from \"../types\";\nimport { MAX_SPEED } from \"../constants\";\n\nconst countingSort = async (\n  array: Array<ArrayItem>,\n  digit: number,\n  setArray: (array: Array<ArrayItem>) => void,\n  speed: number,\n  isLastPass: boolean\n) => {\n  const sortedArray = new Array(array.length).fill(0);\n  const countArray = new Array(10).fill(0);\n\n  const digitColumn = 10 ** digit;\n\n  for (let i = 0; i < array.length; i++) {\n    setColour(i, ELEMENT_COLOURS.FOCUSED, array);\n    setArray([...array]);\n    const countIndex = Math.floor(array[i].value / digitColumn) % 10;\n    countArray[countIndex]++;\n    await sleep(0);\n    setColour(i, ELEMENT_COLOURS.DEFAULT, array);\n    setArray([...array]);\n  }\n\n  for (let idx = 1; idx < 10; idx++) {\n    countArray[idx] += countArray[idx - 1];\n  }\n\n  for (let idx = array.length - 1; idx > -1; idx--) {\n    setColour(idx, ELEMENT_COLOURS.FOCUSED, array);\n    setArray([...array]);\n    await sleep(0);\n    const countIndex = Math.floor(array[idx].value / digitColumn) % 10;\n    countArray[countIndex]--;\n    const sortedIndex = countArray[countIndex];\n\n    sortedArray[sortedIndex] = array[idx];\n    setColour(idx, ELEMENT_COLOURS.DEFAULT, array);\n    setArray([...array]);\n  }\n\n  for (let idx = 0; idx < array.length; idx++) {\n    setColour(idx, ELEMENT_COLOURS.FOCUSED, array);\n    setArray([...array]);\n    await sleep(0);\n    array[idx] = { ...sortedArray[idx] };\n\n    if (isLastPass) {\n      setColour(idx, ELEMENT_COLOURS.SORTED, array);\n    } else {\n      setColour(idx, ELEMENT_COLOURS.DEFAULT, array);\n    }\n    setArray([...array]);\n    await sleep(MAX_SPEED - speed);\n\n    setArray([...array]);\n  }\n};\n\nexport const radixSort = async (\n  array: Array<ArrayItem>,\n  setArray: (array: Array<ArrayItem>) => void,\n  speed: number\n) => {\n  if (array.length === 0) {\n    return array;\n  }\n\n  const maxNumber = Math.max(...array.map((w) => w.value));\n\n  let maxNumberLength = maxNumber.toString().length;\n\n  for (let i = 0; i < maxNumberLength; i++) {\n    let isLastPass = i === maxNumberLength - 1;\n    await countingSort(array, i, setArray, speed, isLastPass);\n  }\n};\n\nexport const radixSortDescription = (\n  <>\n    <P>\n      <strong>\n        Radix Sort - O(d * (n + b)) time complexity. n = length of the input\n        array, d = max number digits in largest number, b = base of numbering\n        system used\n      </strong>\n    </P>\n    <P>\n      This implementation of Radix Sort sorts each number based on its{\" \"}\n      <Link\n        href=\"https://en.wikipedia.org/wiki/Radix\"\n        target=\"_blank\"\n        rel=\"noopener noreferrer\"\n      >\n        radix\n      </Link>{\" \"}\n      at a specific position. This operation is repeated for each digit in the\n      numbers, whilst also preserving the order of the list from the previous\n      iteration. The algorithm passes over the array to calculate the max\n      number, and therefore the maximum number of digits in the array.{\" \"}\n      <strong>E.G.</strong> with the numbers [43, 106, 9, 155] - on the first\n      pass the order of the array will change to [4\n      <Highlight>3</Highlight>, 15<Highlight>5</Highlight>, 10\n      <Highlight>6</Highlight>, <Highlight>9</Highlight>]. They have been sorted\n      by the first radix (the right most digit in each number). After the second\n      pass a 0 is prefixed before the 9, and this becomes [\n      <Highlight>0</Highlight>9, 1<Highlight>0</Highlight>6,{\" \"}\n      <Highlight>4</Highlight>3, 1<Highlight>5</Highlight>5]. After the final\n      pass another 0 is prefixed before the 9 and one is prefixed before the 43,\n      and this becomes [<Highlight>0</Highlight>09, <Highlight>0</Highlight>43,{\" \"}\n      <Highlight>1</Highlight>06, <Highlight>1</Highlight>55].\n    </P>\n  </>\n);\n","import * as S from \"./App.styles\";\n\nimport { ArrayItem, SortingAlgorithm } from \"./types\";\nimport { MAX_ARRAY_SIZE, MAX_SPEED } from \"./constants\";\nimport {\n  bubbleSort,\n  bubbleSortDescription,\n  insertionSort,\n  insertionSortDescription,\n  quickSort,\n  quickSortDescription,\n  radixSort,\n  radixSortDescription,\n  selectionSort,\n  selectionSortDescription,\n} from \"./algorithms\";\nimport { createArrayItem, shuffle } from \"./utils\";\nimport { useEffect, useRef, useState } from \"react\";\n\nimport { Normalize } from \"styled-normalize\";\n\nconst App = () => {\n  const [array, setArray] = useState<Array<ArrayItem>>([]);\n  const [inProgress, setInProgress] = useState(false);\n  const [arraySize, setArraySize] = useState(50);\n  const [maxArraySize, setMaxArraySize] = useState(MAX_ARRAY_SIZE);\n  const [sortSpeed, setSortSpeed] = useState(Math.floor(MAX_SPEED / 2));\n  const [sortingAlgorithm, setSortingAlgorithm] = useState(\n    SortingAlgorithm.BubbleSort\n  );\n  const mainContentWidth = useRef(null);\n\n  useEffect(() => {\n    if (\n      mainContentWidth &&\n      mainContentWidth.current &&\n      // @ts-ignore\n      mainContentWidth.current.offsetWidth\n    ) {\n      const number =\n        // @ts-ignore\n        (mainContentWidth.current.offsetWidth - 80) /\n        (S.BAR_WIDTH + S.BAR_SPACE);\n      setMaxArraySize(Math.floor(number));\n    }\n  }, [mainContentWidth]);\n\n  useEffect(() => {\n    shuffleArray(arraySize);\n  }, [arraySize]);\n\n  const sortArray = async () => {\n    setInProgress(true);\n\n    switch (sortingAlgorithm) {\n      case SortingAlgorithm.BubbleSort:\n        await bubbleSort(array, setArray, sortSpeed);\n        break;\n      case SortingAlgorithm.SelectionSort:\n        await selectionSort(array, setArray, sortSpeed);\n        break;\n      case SortingAlgorithm.InsertionSort:\n        await insertionSort(array, setArray, sortSpeed);\n        break;\n      case SortingAlgorithm.QuickSort:\n        await quickSort(array, setArray, sortSpeed);\n        break;\n      case SortingAlgorithm.RadixSort:\n        await radixSort(array, setArray, sortSpeed);\n        break;\n    }\n\n    setInProgress(false);\n  };\n\n  const shuffleArray = async (arraySize: number) => {\n    const array: Array<ArrayItem> = Array.from({\n      length: arraySize,\n    }).map((_, i) => createArrayItem(i + 1));\n    const shuffled = shuffle(array);\n    setArray(shuffled);\n  };\n\n  const getAlgorithmDescription = () => {\n    switch (sortingAlgorithm) {\n      case SortingAlgorithm.BubbleSort:\n        return bubbleSortDescription;\n      case SortingAlgorithm.InsertionSort:\n        return insertionSortDescription;\n      case SortingAlgorithm.SelectionSort:\n        return selectionSortDescription;\n      case SortingAlgorithm.QuickSort:\n        return quickSortDescription;\n      case SortingAlgorithm.RadixSort:\n        return radixSortDescription;\n    }\n  };\n\n  const isAlgoDisabled = (key: SortingAlgorithm) => {\n    switch (key) {\n      case SortingAlgorithm.MergeSort:\n      case SortingAlgorithm.HeapSort:\n      case SortingAlgorithm.BogoSort:\n        return true;\n      default:\n        return false;\n    }\n  };\n\n  return (\n    <>\n      <Normalize />\n      <S.Wrapper>\n        <S.Rows>\n          <S.ArrayWrapper ref={mainContentWidth}>\n            {array.map((w, idx) => (\n              <div\n                style={{\n                  width: `${S.BAR_WIDTH}px`,\n                  marginLeft: `${S.BAR_SPACE}px`,\n                  color: \"transparent\",\n                  display: \"inline-block\",\n                  height: `${w.value * 3}px`,\n                  backgroundColor: w.colour,\n                }}\n                key={idx}\n              />\n            ))}\n          </S.ArrayWrapper>\n          <S.Description>\n            <>\n              {getAlgorithmDescription()}\n              <S.P small>\n                <strong>\n                  <em>Note: </em>\n                </strong>\n                Don't infer the speed of each algorithm based on the speed of\n                the visualisation. In order for the visualisations to show the\n                individual steps in the algorithms, some may have been slowed\n                down more than others.\n              </S.P>\n            </>\n          </S.Description>\n        </S.Rows>\n        <S.ToolBar>\n          <S.Select\n            value={sortingAlgorithm}\n            onChange={(event) => {\n              const { value } = event.target;\n              const typedValue = value as SortingAlgorithm;\n              shuffleArray(arraySize);\n              setSortingAlgorithm(typedValue);\n            }}\n            disabled={inProgress}\n          >\n            {Object.values(SortingAlgorithm).map((value) => (\n              <option\n                key={value}\n                value={value}\n                disabled={isAlgoDisabled(value)}\n              >\n                {value}\n              </option>\n            ))}\n          </S.Select>\n          <S.SliderWrapper>\n            <S.SliderDescription>Array Size</S.SliderDescription>\n            <S.Slider\n              disabled={inProgress}\n              value={arraySize}\n              onChange={(val) => {\n                setArraySize(Number(val.target.value));\n              }}\n              type=\"range\"\n              min=\"20\"\n              max={maxArraySize}\n            />\n          </S.SliderWrapper>\n\n          <S.SliderWrapper>\n            <S.SliderDescription>Sort Speed</S.SliderDescription>\n            <S.Slider\n              disabled={inProgress}\n              value={sortSpeed}\n              onChange={(val) => {\n                setSortSpeed(Number(val.target.value));\n              }}\n              type=\"range\"\n              min=\"0\"\n              max={MAX_SPEED}\n            />\n          </S.SliderWrapper>\n          <S.Button\n            disabled={inProgress}\n            onClick={() => shuffleArray(arraySize)}\n          >\n            Shuffle\n          </S.Button>\n          <S.Button primary disabled={inProgress} onClick={sortArray}>\n            Sort\n          </S.Button>\n          <S.Credits>\n            Made by{\" \"}\n            <S.Link\n              href=\"https://twitter.com/seanbarryuk\"\n              target=\"_new\"\n              rel=\"noopener nofollow\"\n            >\n              @SeanBarryUK\n            </S.Link>\n          </S.Credits>\n        </S.ToolBar>\n      </S.Wrapper>\n    </>\n  );\n};\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import App from \"./App\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}